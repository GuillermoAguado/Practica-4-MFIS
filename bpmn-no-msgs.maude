sload time.maude

--- Identificadores
mod Id is
    protecting STRING .
    sort Id .
    op id : String -> Id .
endm

view Id from TRIV to Id is
    sort Elt to Id .
endv

mod Node is 
    protecting Id .
    sort Node .
    op start : Id Id -> Node [ctor] .
    op end : Id Id -> Node [ctor] .
endm

view Node from TRIV to Node is
    sort Elt to Node .
endv

mod Resource is 
    protecting Id .
    protecting NAT .
    sort Resource .
    op resource : Id Nat Nat -> Resource [ctor] .
endm

view Resource from TRIV to Resource is
    sort Elt to Resource .
endv

mod Flow is 
    protecting Id .
    protecting POSRAT-TIME-DOMAIN-WITH-INF .
    sort Flow .
    op flow : Id Time -> Flow [ctor] .
endm

view Flow from TRIV to Flow is
    sort Elt to Flow .
endv

mod Token is 
    protecting POSRAT-TIME-DOMAIN-WITH-INF .
    protecting Id .
    sort Token .
    op token : Id Time -> Token [ctor] .
endm

view Token from TRIV to Token is
    sort Elt to Token .
endv

mod BPMN-SEM is
    --- Tiempo
    protecting POSRAT-TIME-DOMAIN-WITH-INF .
    --- Identificadores
    protecting Id .
    protecting SET{Id} .
    --- Puertas
    sort Gateway .
    op exclusive : -> Gateway [ctor] .
    op parallel : -> Gateway [ctor] .
    --- Nodos
    protecting Node .
    protecting SET{Node} .
    --- Tarea
    op task : Id String Id Id Time Set{Id} -> Node [ctor] .
    --- Split
    op split : Id Gateway Id Set{Id} -> Node [ctor] .
    --- Merge
    op merge : Id Gateway Set{Id} Id -> Node [ctor] .
    --- Recursos
    protecting Resource .
    protecting SET{Resource} .
    --- Flujo
    protecting Flow .
    protecting SET{Flow} .
    --- Token
    protecting Token .
    protecting SET{Token} .
    --- Proceso
    including CONFIGURATION .
    sort Process .
    subsort Process < Cid .
    op Process : -> Process .
    op nodes:_ : Set{Node} -> Attribute [gather(&)] .        
    op flows:_ : Set{Flow} -> Attribute [gather(&)] .
    op tokens:_ : Set{Token} -> Attribute [gather(&)] .
    op gtime:_ : Time -> Attribute [gather(&)] .
    op resources:_ : Set{Resource} -> Attribute [gather(&)] .

    --- class Process | nodes: Set{Node},
    ---                flows: Set{Flow},
    ---                tokens: List{Token},
    ---                gtime: Time,
    ---                resources: Set{Resource},
    ---                events: Set{EventInstance} . 

    var o : Oid .
    var VProcess : Process .
    vars id1 id2 id3 id4 : Id .
    vars N M : Nat .
    var name :  String .
    var setNode1 : Set{Node} .
    var setFlow1 : Set{Flow} .
    var setId1 : Set{Id} .
    var setToken1 : Set{Token} .
    var setResource1 : Set{Resource} .
    var resource1 : Resource .
    vars time1 time2 time3 timeGlobal T' : Time .
    var Atts : AttributeSet .
    var gateway : Gateway .
    var conf : Configuration .
    
    --- Operaciones
    
    op delta : Set{Token} Time -> Set{Token} .
    eq delta(empty, time1) = empty .
    eq delta((token(id1, time2), setToken1), time1) = ( token(id1, time2 monus time1),delta(setToken1,time1)) .

    op mte : Configuration -> TimeInf .
    eq mte(none) = INF .
    eq mte(< o : VProcess | nodes: setNode1, flows: setFlow1, tokens: empty, Atts >) = INF .
    ceq mte(< o : VProcess | nodes: (task(id2, name, id1, id3, time2, setId1),setNode1), flows: (flow(id1, time2), setFlow1), tokens: (token(id1, time1), setToken1), Atts >) 
        = minimum(INF, mte(< o : VProcess | nodes: (task(id2, name, id1, id3, time2, setId1),setNode1), flows: (flow(id1, time2), setFlow1), tokens: setToken1, Atts >)) 
        if blockedTask(token(id1, time1),< o : VProcess | nodes: (task(id2, name, id1, id3, time2, setId1),setNode1), flows: (flow(id1, time2), setFlow1), tokens: (token(id1, time1), setToken1), Atts >) .

    ceq mte(< o : VProcess | nodes: (merge(id1, parallel, (id3, setId1), id2),setNode1), flows: (flow(id3, time3), setFlow1), tokens: (token(id3, 0), setToken1), Atts >) 
        = minimum(INF, mte(< o : VProcess | nodes: (merge(id1, parallel, (id3, setId1), id2),setNode1), flows: (flow(id3, time3), setFlow1), tokens: setToken1, Atts >)) 
        if blockedMerge(id1, < o : VProcess | nodes: (merge(id1, parallel, (id3, setId1), id2),setNode1), flows: (flow(id3, time3), setFlow1), tokens: (token(id3, 0), setToken1), Atts >) .
    
    eq mte(< o : VProcess | nodes: setNode1, flows: setFlow1, tokens: (token(id1, time1), setToken1), Atts >) 
        = minimum(time1, mte(< o : VProcess | nodes: setNode1, flows: setFlow1, tokens: setToken1, Atts >)) [owise] . ---meter el if bloqueado
    
    op blockedTask : Token Configuration -> Bool . --- true si bloqueado, si no falso
    eq blockedTask(token(id1, 0), < o : VProcess | nodes: (task(id2, name, id1, id3, time2, empty), setNode1), resources: setResource1,  Atts >) = false .
    ceq blockedTask(token(id1, 0), < o : VProcess | nodes: (task(id2, name, id1, id3, time2, (id4, setId1)), setNode1), resources: (resource(id4, N, M),setResource1),  Atts >) = true 
        if M = 0 .
    eq blockedTask(token(id1, 0), < o : VProcess | nodes: (task(id2, name, id1, id3, time2, (id4, setId1)), setNode1), resources: (resource(id4, N, M),setResource1),  Atts >) = 
        blockedTask(token(id1, 0), < o : VProcess | nodes: (task(id2, name, id1, id3, time2, setId1), setNode1), resources: (resource(id4, N, M),setResource1),  Atts >) [owise] . 
    
    op blockedMerge : Id Configuration -> Bool . --- true si bloqueado, sino falso
    eq blockedMerge(id1, < o : VProcess | nodes: (merge(id1, parallel, empty, id2), setNode1), flows: (flow(id2, time2), setFlow1), tokens: setToken1, Atts >) = false .
    eq blockedMerge(id1, < o : VProcess | nodes: (merge(id1, parallel, (id3, setId1), id2), setNode1), flows: (flow(id2, time2), setFlow1), tokens: (token(id3, 0), setToken1), Atts >) =
        blockedMerge(id1, < o : VProcess | nodes: (merge(id1, parallel, setId1, id2), setNode1), flows: (flow(id2, time2), setFlow1), tokens: setToken1, Atts >) .
    eq blockedMerge(id1, < o : VProcess | nodes: (merge(id1, parallel, (id3, setId1), id2), setNode1), flows: (flow(id2, time2), setFlow1), tokens: setToken1, Atts >) = true [owise] . --- rf



    op subtractResource : Set{Id} Set{Resource} -> Set{Resource} .
    eq subtractResource(empty, setResource1) = setResource1 . 
    eq subtractResource((id1, setId1), (resource(id1, N, M),setResource1)) = (resource(id1, N, sd(M, 1)), subtractResource(setId1, setResource1)) .

    op addResource : Set{Id} Set{Resource} -> Set{Resource} .
    eq addResource(empty, setResource1) = setResource1 . 
    eq addResource((id1, setId1), (resource(id1, N, M),setResource1)) = (resource(id1, N, s M), addResource(setId1, setResource1)) .

    op createTokens : Set{Id} Set{Flow} -> Set{Token} . 
    eq createTokens(empty, setFlow1) = empty .
    eq createTokens((id1, setId1), (flow(id1, time1),setFlow1)) = (token(id1, time1), createTokens(setId1, setFlow1)) . 
    
    op subtractTokens : Set{Id} Set{Token} -> Set{Token} .
    eq subtractTokens(empty, setToken1) = setToken1 .
    eq subtractTokens((id1, setId1), (token(id1, time1),setToken1)) = subtractTokens(setId1, setToken1) .
    
    --- Reglas
    
    --- tick rule should not advance time beyond expiration of a timer
    crl [tick] : < o : VProcess | tokens: setToken1, gtime: timeGlobal, Atts > 
                => < o : VProcess | tokens: delta(setToken1, T'), gtime: timeGlobal plus T', Atts >
                if T' := mte(< o : VProcess | tokens: setToken1, gtime: timeGlobal, Atts >) /\ 0 < T' /\ timeGlobal < 100 .
    
    rl [start] : < o : VProcess | nodes: (start(id1, id2), setNode1), flows: (flow(id2, time1), setFlow1), tokens: (token(id1, 0), setToken1), Atts > 
        => < o : VProcess | nodes: (start(id1, id2), setNode1), flows: (flow(id2, time1), setFlow1), tokens: (token(id2, time1), setToken1), Atts >  .

    crl [flowTask] : < o : VProcess | nodes: (task(id2, name, id1, id3, time2, setId1), setNode1), tokens: (token(id1, 0), setToken1), resources: setResource1, Atts > 
        => < o : VProcess | nodes: (task(id2, name, id1, id3, time2, setId1), setNode1), tokens: (token(id2, time2), setToken1), resources: subtractResource(setId1,setResource1), Atts > 
        if not(blockedTask(token(id1, 0), < o : VProcess | nodes: (task(id2, name, id1, id3, time2, setId1), setNode1), tokens: (token(id2, 0), setToken1), resources: setResource1, Atts >)) .
    
    rl [task] : < o : VProcess | nodes: (task(id2, name, id1, id3, time2, setId1), setNode1), flows: (flow(id3, time3), setFlow1), tokens: (token(id2, 0), setToken1), resources: setResource1, Atts > 
        => < o : VProcess | nodes: (task(id2, name, id1, id3, time2, setId1), setNode1), flows: (flow(id3, time3), setFlow1), tokens: (token(id3, time3), setToken1), resources: addResource(setId1, setResource1), Atts > .

    rl [flowEnd] : < o : VProcess | nodes: (end(id2, id1), setNode1), flows: (flow(id1, time1), setFlow1), tokens: (token(id1, 0), setToken1), Atts > 
        => < o : VProcess | nodes: (end(id2, id1), setNode1), flows: (flow(id1, time1), setFlow1), tokens: setToken1, Atts > .
    
    rl [mergeExclusive] : < o : VProcess | nodes: (merge(id1, exclusive, (id3, setId1), id2), setNode1), flows: (flow(id2, time2), setFlow1), tokens: (token(id3, 0), setToken1), Atts >
        => < o : VProcess | nodes: (merge(id1, exclusive, (id3, setId1), id2), setNode1), flows: (flow(id2, time2), setFlow1), tokens: (token(id2, time2), setToken1), Atts > .
    
    rl [splitExclusive] : < o : VProcess | nodes: (split(id2, exclusive, id1, (id3, setId1)), setNode1), flows: (flow(id3, time3), setFlow1), tokens: (token(id1, 0), setToken1), Atts >
        => < o : VProcess | nodes: (split(id2, exclusive, id1, (id3, setId1)), setNode1), flows: (flow(id3, time3), setFlow1), tokens: (token(id3, time3), setToken1), Atts > .

    crl [mergeParallel] : < o : VProcess | nodes: (merge(id1, parallel, (id3, setId1), id2), setNode1), flows: (flow(id2, time2), setFlow1), tokens: (token(id3, 0), setToken1), Atts >
        => < o : VProcess | nodes: (merge(id1, parallel, (id3, setId1), id2), setNode1), flows: (flow(id2, time2), setFlow1), tokens: (token(id2, time2), subtractTokens(setId1, setToken1)), Atts > 
        if not(blockedMerge(id1, < o : VProcess | nodes: (merge(id1, parallel, (id3, setId1), id2), setNode1), flows: (flow(id2, time2), setFlow1), tokens: (token(id3, 0), setToken1), Atts >)) .

    rl [splitParallel] : < o : VProcess | nodes: (split(id2, parallel, id1, (id3, setId1)), setNode1), flows: (flow(id3, time3), setFlow1), tokens: (token(id1, 0), setToken1), Atts >
        => < o : VProcess | nodes: (split(id2, parallel, id1, (id3, setId1)), setNode1), flows: (flow(id3, time3), setFlow1), tokens: (token(id3, time3), createTokens(setId1, setFlow1), setToken1), Atts > .
    
    --- para pasar de un elemento a otro le pones al token el id del elemento al que va y el time del elemento al que va
endm

eof

red mte(< o : Process | 
        nodes: (start(id("00"), id("01")),
                task(id("02"), "Sign in", id("01"), id("03"), 2, empty),
                end(id("04"), id("03"))), 
        flows: (flow(id("01"), 2),
                flow(id("03"), 2)),
        gtime: 0,
        tokens: (token(id("00"), 4),token(id("10"), 3),token(id("20"), 2)),

        resources: empty >) .

--- Codigo otro dia
 ceq mte(< o : VProcess | nodes: setNode1, flows: setFlow1, tokens: (token(id1, time1), setToken1), Atts >) 
        = minimum(time1, mte(< o : VProcess | nodes: setNode1, flows: setFlow1, tokens: setToken1, Atts >)) 
        if checkBlock(token(id1, time1), < o : VProcess | nodes: setNode1, flows: setFlow1, tokens: (token(id1, time1), setToken1), Atts >) . ---meter el if bloqueado
    
    ---op comprobarBlock : Token Configuration -> Bool
    op checkBlock : Token Configuration -> Bool .
    eq checkBlock(token(id1, time1), conf) = checkResources(id1, conf) and true .
        ---op comprobarRecursos : Token Configuration -> Bool
            ---ver que idToken es idTask and alguno de los recursos de Task no es mayor que 0
    op checkResources : Id Configuration -> Bool . ---false si no es tarea o si es tarea y hay recursos
                                                    --- true si es tarea y no hay recursos
    eq checkResources(id2, < o : VProcess | nodes: task(id2, name, id1, id3, time2, setId1), tokens: setToken1, resources: setResource1, Atts >) = 
        isTask() and not(resourcesAvailable(task(id2, name, id1, id3, time2, setId1), setResource1)) .

    op isTask : Id Set{Node} -> Bool . ---true si es tarea
    eq isTask(id1, empty) = false .
    eq isTask(id4, (task(id4, name, id1, id3, time2, setId1), setNode1)) = true .--- task con mismo id
    eq isTask(id4, (task(id2, name, id1, id3, time2, setId1), setNode1)) = isTask(id4,setNode1) .--- task con distinto id
    eq isTask(id4, (end(id1,id2), setNode1)) = isTask(id4,setNode1) .--- end
    eq isTask(id4, (start(id1,id2), setNode1)) = isTask(id4,setNode1) . --- start
    eq isTask(id4, (merge(id1, gateway, (id3, setId1), id2), setNode1)) = isTask(id4,setNode1) .  --- merge
    eq isTask(id4, (split(id2, gateway, id1, (id3, setId1)), setNode1)) = isTask(id4,setNode1) .  --- split

    op resourcesAvailable : Node Set{Resource} -> Bool . --- true si disponibles
    eq resourcesAvailable(task(id2, name, id1, id3, time2, empty), setResource1) = true .
    eq resourcesAvailable(task(id2, name, id1, id3, time2, (id4,setId1)), (resource(id4, N, M), setResource1)) = 
        M > 0 and resourcesAvailable(task(id2, name, id1, id3, time2, (setId1)), setResource1) .
        ---  and
        ---op comprobarMergeParallel : Token Configuration -> Bool
            ---ver que idToken está incluido en set{Id} del merge Parallel and comprobar el resto de ids y ver si alguno de ellos no es 0